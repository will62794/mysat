@article{lin2004assat,
  title={ASSAT: Computing answer sets of a logic program by SAT solvers},
  author={Lin, Fangzhen and Zhao, Yuting},
  journal={Artificial Intelligence},
  volume={157},
  number={1-2},
  pages={115--137},
  year={2004},
  publisher={Elsevier}
}
@article{tan2014undecidability,
  title={Undecidability of satisfiability in the algebra of finite binary relations with union, composition, and difference},
  author={Tan, Tony and Bussche, Jan Van den and Zhang, Xiaowang},
  journal={arXiv preprint arXiv:1406.0349},
  year={2014}
}
@inproceedings{chou2018dissociation,
  title={Dissociation-Based Oblivious Bounds for Weighted Model Counting.},
  author={Chou, Li and Gatterbauer, Wolfgang and Gogate, Vibhav},
  booktitle={UAI},
  pages={866--875},
  year={2018}
}
@misc{dimacsCNF,
  author       = {},
  howpublished = {\url{https://people.sc.fsu.edu/~jburkardt/data/cnf/cnf.html}},
  title        = {{CNF Files}},
  year         = {}
}
@inproceedings{71cook,
author = {Cook, Stephen A.},
title = {The Complexity of Theorem-Proving Procedures},
year = {1971},
isbn = {9781450374644},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/800157.805047},
doi = {10.1145/800157.805047},
abstract = {It is shown that any recognition problem solved by a polynomial time-bounded nondeterministic Turing machine can be “reduced” to the problem of determining whether a given propositional formula is a tautology. Here “reduced” means, roughly speaking, that the first problem can be solved deterministically in polynomial time provided an oracle is available for solving the second. From this notion of reducible, polynomial degrees of difficulty are defined, and it is shown that the problem of determining tautologyhood has the same polynomial degree as the problem of determining whether the first of two given graphs is isomorphic to a subgraph of the second. Other examples are discussed. A method of measuring the complexity of proof procedures for the predicate calculus is introduced and discussed.},
booktitle = {Proceedings of the Third Annual ACM Symposium on Theory of Computing},
pages = {151–158},
numpages = {8},
location = {Shaker Heights, Ohio, USA},
series = {STOC '71}
}
@book{09bieresathandbook,
author = {Biere, A. and Biere, A. and Heule, M. and van Maaren, H. and Walsh, T.},
title = {Handbook of Satisfiability: Volume 185 Frontiers in Artificial Intelligence and Applications},
year = {2009},
isbn = {1586039296},
publisher = {IOS Press},
address = {NLD},
abstract = { 'Satisfiability (SAT) related topics have attracted researchers from various disciplines: logic, applied areas such as planning, scheduling, operations research and combinatorial optimization, but also theoretical issues on the theme of complexity and much more, they all are connected through SAT. My personal interest in SAT stems from actual solving: The increase in power of modern SAT solvers over the past 15 years has been phenomenal. It has become the key enabling technology in automated verification of both computer hardware and software. Bounded Model Checking (BMC) of computer hardware is now probably the most widely used model checking technique. The counterexamples that it finds are just satisfying instances of a Boolean formula obtained by unwinding to some fixed depth a sequential circuit and its specification in linear temporal logic. Extending model checking to software verification is a much more difficult problem on the frontier of current research. One promising approach for languages like C with finite word-length integers is to use the same idea as in BMC but with a decision procedure for the theory of bit-vectors instead of SAT. All decision procedures for bit-vectors that I am familiar with ultimately make use of a fast SAT solver to handle complex formulas. Decision procedures for more complicated theories, like linear real and integer arithmetic, are also used in program verification. Most of them use powerful SAT solvers in an essential way. Clearly, efficient SAT solving is a key technology for 21st century computer science. I expect this collection of papers on all theoretical and practical aspects of SAT solving will be extremely useful to both students and researchers and will lead to many further advances in the field.' Edmund Clarke (FORE Systems University Professor of Computer Science and Professor of Electrical and Computer Engineering at Carnegie Mellon University)}
}
@misc{bierecdcl,
  author       = {},
  howpublished = {\url{https://www.cs.princeton.edu/~zkincaid/courses/fall18/readings/SATHandbook-CDCL.pdf}},
  title        = {{Conflict-Driven Clause Learning SAT Solvers}},
  year         = {2008}
}
@misc{2020satresults,
  author       = {},
  howpublished = {\url{https://satcompetition.github.io/2020/results.html}},
  title        = {{SAT Competition 2020 Results}},
  year         = {}
}
@misc{minisat,
  author       = {},
  howpublished = {\url{http://minisat.se/}},
  title        = {{MiniSat SAT Solver}},
  year         = {}
}

@article{1960dpll,
author = {Davis, Martin and Putnam, Hilary},
title = {A Computing Procedure for Quantification Theory},
year = {1960},
issue_date = {July 1960},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {7},
number = {3},
issn = {0004-5411},
url = {https://doi.org/10.1145/321033.321034},
doi = {10.1145/321033.321034},
abstract = {The hope that mathematical methods employed in the investigation of formal logic would lead to purely computational methods for obtaining mathematical theorems goes back to Leibniz and has been revived by Peano around the turn of the century and by Hilbert's school in the 1920's. Hilbert, noting that all of classical mathematics could be formalized within quantification theory, declared that the problem of finding an algorithm for determining whether or not a given formula of quantification theory is valid was the central problem of mathematical logic. And indeed, at one time it seemed as if investigations of this “decision” problem were on the verge of success. However, it was shown by Church and by Turing that such an algorithm can not exist. This result led to considerable pessimism regarding the possibility of using modern digital computers in deciding significant mathematical questions. However, recently there has been a revival of interest in the whole question. Specifically, it has been realized that while no decision procedure exists for quantification theory there are many proof procedures available—that is, uniform procedures which will ultimately locate a proof for any formula of quantification theory which is valid but which will usually involve seeking “forever” in the case of a formula which is not valid—and that some of these proof procedures could well turn out to be feasible for use with modern computing machinery.Hao Wang [9] and P. C. Gilmore [3] have each produced working programs which employ proof procedures in quantification theory. Gilmore's program employs a form of a basic theorem of mathematical logic due to Herbrand, and Wang's makes use of a formulation of quantification theory related to those studied by Gentzen. However, both programs encounter decisive difficulties with any but the simplest formulas of quantification theory, in connection with methods of doing propositional calculus. Wang's program, because of its use of Gentzen-like methods, involves exponentiation on the total number of truth-functional connectives, whereas Gilmore's program, using normal forms, involves exponentiation on the number of clauses present. Both methods are superior in many cases to truth table methods which involve exponentiation on the total number of variables present, and represent important initial contributions, but both run into difficulty with some fairly simple examples.In the present paper, a uniform proof procedure for quantification theory is given which is feasible for use with some rather complicated formulas and which does not ordinarily lead to exponentiation. The superiority of the present procedure over those previously available is indicated in part by the fact that a formula on which Gilmore's routine for the IBM 704 causes the machine to computer for 21 minutes without obtaining a result was worked successfully by hand computation using the present method in 30 minutes. Cf. §6, below.It should be mentioned that, before it can be hoped to employ proof procedures for quantification theory in obtaining proofs of theorems belonging to “genuine” mathematics, finite axiomatizations, which are “short,” must be obtained for various branches of mathematics. This last question will not be pursued further here; cf., however, Davis and Putnam [2], where one solution to this problem is given for ele},
journal = {J. ACM},
month = {jul},
pages = {201–215},
numpages = {15}
}
@InProceedings{09cryptominisat,
author="Soos, Mate
and Nohl, Karsten
and Castelluccia, Claude",
editor="Kullmann, Oliver",
title="Extending SAT Solvers to Cryptographic Problems",
booktitle="Theory and Applications of Satisfiability Testing - SAT 2009",
year="2009",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="244--257",
abstract="Cryptography ensures the confidentiality and authenticity of information but often relies on unproven assumptions. SAT solvers are a powerful tool to test the hardness of certain problems and have successfully been used to test hardness assumptions. This paper extends a SAT solver to efficiently work on cryptographic problems. The paper further illustrates how SAT solvers process cryptographic functions using automatically generated visualizations, introduces techniques for simplifying the solving process by modifying cipher representations, and demonstrates the feasibility of the approach by solving three stream ciphers.",
isbn="978-3-642-02777-2"
}
@misc{2020kissat,
  author       = {},
  howpublished = {\url{http://fmv.jku.at/kissat/}},
  title        = {{Kissat SAT Solver}},
  year         = {}
}
@INPROCEEDINGS{96sakallah,  
author={Marques Silva, J.P. and Sakallah, K.A.},  
booktitle={Proceedings of International Conference on Computer Aided Design},   
title={{GRASP-A new search algorithm for satisfiability}},   
year={1996},  volume={},  number={},  pages={220-227},  doi={10.1109/ICCAD.1996.569607}}

@book{2012benarilogic,
author = {Ben-Ari, Mordechai},
title = {Mathematical Logic for Computer Science},
year = {2012},
isbn = {1447141288},
publisher = {Springer Publishing Company, Incorporated},
edition = {3rd},
abstract = {Mathematical Logic for Computer Science is a mathematics textbook with theorems and proofs, but the choice of topics has been guided by the needs of students of computer science. The method of semantic tableaux provides an elegant way to teach logic that is both theoretically sound and easy to understand. The uniform use of tableaux-based techniques facilitates learning advanced logical systems based on what the student has learned from elementary systems. The logical systems presented are: propositional logic, first-order logic, resolution and its application to logic programming, Hoare logic for the verification of sequential programs, and linear temporal logic for the verification of concurrent programs. The third edition has been entirely rewritten and includes new chapters on central topics of modern computer science: SAT solvers and model checking.}
}
@misc{sat2020benchmarks,
  author       = {},
  howpublished = {\url{https://satcompetition.github.io/2020/benchmarks.html}},
  title        = {{SAT Competition 2020: Benchmarks}},
  year         = {}
}
@INPROCEEDINGS{goldberg03,
  author={Goldberg, E. and Novikov, Y.},
  booktitle={2003 Design, Automation and Test in Europe Conference and Exhibition}, 
  title={Verification of proofs of unsatisfiability for CNF formulas}, 
  year={2003},
  volume={},
  number={},
  pages={886-891},
  doi={10.1109/DATE.2003.1253718}}
@INPROCEEDINGS{heule13,
  author={Heule, Marijn J.H. and Hunt, Warren A. and Wetzler, Nathan},
  booktitle={2013 Formal Methods in Computer-Aided Design}, 
  title={Trimming while checking clausal proofs}, 
  year={2013},
  volume={},
  number={},
  pages={181-188},
  doi={10.1109/FMCAD.2013.6679408}}
https://www.cs.utexas.edu/~marijn/drat-trim/

@misc{drattrimtool,
  author       = {Heule, Marijn J.H.},
  howpublished = {\url{https://www.cs.utexas.edu/~marijn/drat-trim/}},
  title        = {{DRAT-trim}},
  year         = {}
}
@article{dpll1961,
author = {Davis, Martin and Logemann, George and Loveland, Donald},
title = {A Machine Program for Theorem-Proving},
year = {1962},
issue_date = {July 1962},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {5},
number = {7},
issn = {0001-0782},
url = {https://doi.org/10.1145/368273.368557},
doi = {10.1145/368273.368557},
abstract = {The programming of a proof procedure is discussed in connection with trial runs and possible improvements.},
journal = {Commun. ACM},
month = {jul},
pages = {394–397},
numpages = {4}
}
@InProceedings{2019sooscrystalball,
author="Soos, Mate
and Kulkarni, Raghav
and Meel, Kuldeep S.",
editor="Janota, Mikol{\'a}{\v{s}}
and Lynce, In{\^e}s",
title={{CrystalBall: Gazing in the Black Box of SAT Solving}},
booktitle="Theory and Applications of Satisfiability Testing -- SAT 2019",
year="2019",
publisher="Springer International Publishing",
address="Cham",
pages="371--387",
abstract="Boolean satisfiability is a fundamental problem in computer science with a wide range of applications including planning, configuration management, design and verification of software/hardware systems. The annual SAT competition continues to witness impressive improvements in the performance of the winning SAT solvers largely thanks to the development of new heuristics arising out of intensive collaborative research in the SAT community. Modern SAT solvers achieve scalability and robustness with sophisticated heuristics that are challenging to understand and explain. Consequently, the development of new algorithmic insights has been primarily restricted to expert intuitions and evaluation of the new insights have been restricted to performance measurement in terms of the runtime of solvers or a proxy for the runtime of solvers. In this context, one may ask: whether it is possible to develop a framework to provide white-box access to the execution of SAT solver that can aid both SAT solver developers and users to synthesize algorithmic heuristics for modern SAT solvers?",
isbn="978-3-030-24258-9"
}
@InProceedings{04minisat,
author="E{\'e}n, Niklas
and S{\"o}rensson, Niklas",
editor="Giunchiglia, Enrico
and Tacchella, Armando",
title="An Extensible SAT-solver",
booktitle="Theory and Applications of Satisfiability Testing",
year="2004",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="502--518",
abstract="In this article, we present a small, complete, and efficient SAT-solver in the style of conflict-driven learning, as exemplified by Chaff. We aim to give sufficient details about implementation to enable the reader to construct his or her own solver in a very short time. This will allow users of SAT-solvers to make domain specific extensions or adaptions of current state-of-the-art SAT-techniques, to meet the needs of a particular application area. The presented solver is designed with this in mind, and includes among other things a mechanism for adding arbitrary boolean constraints. It also supports solving a series of related SAT-problems efficiently by an incremental SAT-interface.",
isbn="978-3-540-24605-3"
}

